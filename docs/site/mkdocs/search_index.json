{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nThis is documentation for controlling a behavioral experiment using an Arduino microcontroller using Python. The experiment can be controlled from a Python command line or with an easy to use web browser interface. Included in this system is an option to simultaneously record video using a Rapsberry Pi video camera. Our goal is to provide a starting point for open-source behavioral experiments that can be extended to new experimental designs.\n\n\n\n\n\n\nFigure 1. Web-browser interface.\n\n\nThe top section provides an interface to start/stop a trial and plots real-time feedback as the trial is running.\n\n\nThe \nStimulus\n section provides an interface to set stimulus parameters and to upload these parameters to an Arduino. This section also provides a plot of the stimulus waveform based on the current set of parameters.\n\n\n\n\nSystem design\n\n\nThe core system consists of an Arduino, a stepper motor and motor driver, and a rotary encoder. The system comes together with a circular \ntreadmill\n that can be driven by the stepper motor and whos current position is read using the rotary encoder.\n\n\nThe Arduino can be controlled with serial commands and can be triggered with general purpose digital input-output (GPIO) pulses. By relying on serial commands and GPIO pulses, this system is not dependent on the details of other pieces of equipment already in place for an experiment and can be extended to new and unique experimental configurations.\n\n\nUsing the provided Python code, an experiment can be controlled from a Python command prompt or a web browser interface.\n\n\n\n\nOptionally, if this code is run on a Raspberry Pi, we provide Python code to simultaneously trigger and time-stamp video recording during an experiment. Please see our \nTrigger Camera\n documentation for a full dscription of how to integrate video recording into this system\n\n\nWe are routinely using this treadmill and video aquisition system while simultaneously acquiring in vivo two-photon images using ScanImage software (in Matlab) with National Instruments data acquisition cards.\n\n\nSee the \nparts list\n for a full list of parts, prices, and links to buy online.\n\n\nArduino\n\n\nThe majority of Arduino compatible micro-controllers will work with the code provided. We suggest starting with an Arduino \nUno\n. An good alternative Arduino compatible microcontroller is the \nTeensy\n. The Teensy is advantageous as it has a more powerful processor, provides more low level interrupts, and has more memory than an Arduino Uno.\n\n\nRaspberry Pi\n\n\nThe \nRaspberry Pi\n is a fully functional credit-card sized computer that runs Linux. It comes with USB, Ethernet, Wifi, and HDMI ports. It can be used as a host computer to program an Arduino using the Arduino IDE and can easily run Python code. A unique feature of the Pi is that it has built in digital GPIO. Thus, a Raspberry Pi can send/receive GPIO signals to/from most laboratory equipment including an Arduino. The Pi can be equipped with a dedicated video camera (5MP or 8MP) that can be controlled from Python and can be (relatively) precisely triggered by GPIO pulses. Given its small footprint, a Raspberry Pi is easily integrated into the same electronics box as the Arduino.\n\n\nPlease note, the GPIO ports on the Rapsberry Pi are only 3.5V tolerant while most laboratory equipment (including many Arduinos and National Instruments boards) use 5V GPIO. Thus, a logic-level converter is needed to convert between 3.5V on the Pi to 5V on other equipment.\n\n\nAs the Raspberry Pi is running a full Linux operating system, the precision and reliability of the GPIO pins is lower than can be achieved using a dedicated microcontroller like an Arduino. Thus, we have built this system using a Teensy microcontroller as a 'pass through' device to record the precise timing of experimental events to then be compared to and to calibrate the performance of the Raspberry Pi. \n\n\nWiring the system\n\n\n\n\nWire the stepper motor to the motor driver\n\n\nWire the Arduino to the motor driver\n\n\nWire the rotary encoder to the Arduino\n\n\nWire the Arduino to existing lab equipment\n\n\nWire the Raspberry Pi to the Arduino.\n\n\n\n\nHere, we are wiring the system to interact with ScanImage software via National Instruments DAQ boards. This can easily be modified by wiring the system to other in-place acquisition systems such as those from Scientifica, Bruger (Prarie), Zeiss, or Nikon.\n\n\nKeep in mind, the Raspberry Pi GPIO pins are \nnot\n 5V tolerant. Use a 5V to 3.5V level shifter to wire the Raspberry Pi to 5V GPIO signals. A Teensy microcontroller is advantageous in that it will accept 5V GPIO input but only outputs 3.5V GPIO. Thus, a Teensy and Raspberry Pi GPIO pins can be directly wired without a level shifter.\n\n\n\n\nTreadmill\n\n\nSee the \nimages\n page and the \ntreadmill section\n of the parts list.\n\n\nBuilding the treamill is easy but finding the pieces to build with can be time-consuming and frustrating. A good starting point is to use \nActobotics\n parts from \nServoCity\n or \nSparkfun\n. In particular, \nServoCity\n, has made a useful set of visual guides and project ideas that are really helpful in designing hardware components. Structural components include: frames, rods, bearings, clamps, and motor mounts.\n\n\nUpload code to the Arduino\n\n\nThe source code for the Arduino can be found in \n/arduino/src/treadmill.cpp\n.\n\n\nRequired libraries\n\n\nNon-blocking Arduino libraries need to be used, otherwise the system will not perform well. Without non-blocking libraries, the code to turn the stepper motor will block other code like reading the rotary encoder and vica versa. Using these non-blocking libraries ensures that (but do not gaurantee) the stepper motor movement does not stutter and all the rotary encoder positions are logged.\n\n\n\n\nAccelStepper\n library to control stepper motor\n\n\nRotary encoder library from \nPJRC\n\n\n\n\nArduino IDE\n\n\nUse the standard \nArduino IDE\n to upload \ntreadmill.cpp\n to an Arduino. Make sure the required Arduino libraries are installed. Be sure to activate additional \nlow level interrupts\n if using an Arduino Uno.\n\n\nPlatformio\n\n\nCode can also be uploaded to an Arduino using \nPlatformIo\n. This has the distinct advantage that code can be compiled and uploaded from the command line on a headless computer including a Raspberry Pi. Please see this blog post to Install PlatformIO, compile code and upload it to an Arduino.\n\n\n\n\nLow Level Interrupts\n\n\nThe Arduino Uno only comes with two pins (2 and 3) capable of low-level interrupts and more pins need to be enabled. Two low level interrupts are needed for the Rotary Encoder, another for a GPIO trigger, and another for GPIO pulses coming from a frame clock. See \nPin-change interrupts\n for information on exposing additional pins as low-level interrupts.\n\n\nWe have included a compiler directive \n_expose_interrupts_\n in the \ntreadmill.cpp\n Arduino code that, if activated, will run code to expose the needed interrupts on an Arduino Uno.\n\n\n\n\nIf using PlatformIO, this is taken care of in the [env] section of platformio.ini\n\n\nIf using the arduino IDE, \ndefine _expose_interrupts_ = 1\n must be included in \ntreadmill.cpp\n\n\n\n\n//Uncomment this line if running on an Arduino Uno and compiling with the arduino IDE\n//#define _expose_interrupts_ 1\n\n\n\n\nPython server setup\n\n\nDownload and install \nAnaconda\n. Anaconda is a \npython\n installation that will install many commonly used libraries. It is much easier to get started with Anaconda rather than a basic installation of Python.\n\n\nPython libraries\n\n\nInstall additional required python libraries using the included requirements.txt file\n\n\npip install -r requirements.txt\n\n\nHere is the requirements.txt file\n\n\neventlet\n=0.18.4\nFlask\n=0.10.1\nFlask-Markdown\n=0.3\nFlask-SocketIO\n=1.0\nplatformio\n=2.8.5\nplotly\n=1.9.6\npyserial\n=3.0.1\n\n\n\n\nRequired python libraries on Raspberry Pi\n\n\npip install -r raspberry_requirements.txt\n\n\npicamera\nRPi.GPIO\n\n\n\n\nRunning an experiment\n\n\nAt its core, an experiment is run on an Arduino by interacting with \ntreadmill.cpp\n through a serial port interface. In addition, a Python command line interface and a web based interface are provided.\n\n\nThese interfaces can be extended by directly interacting with the Arduino code in \ntreadmill.cpp\n (with serial commands), the python code in \ntreadmill.py\n, or the web server code in \ntreadmill_app.py\n.\n\n\nArduino serial interface\n\n\nThe Arduino code \ntreadmill.cpp\n provides a set of serial port commands to get/set parameters and start/stop a trial. Once the code is uploaded to an Arduino, any serial port interface will allow control of an experiment as follows.\n\n\nstartTrial # start a trial\nstopTrial # stop a trial\ngetState #\nsettrial,[name],[value]\n\n\n\n\nsettrial\n takes the \nname\n and \nvalue\n of a trial parameter to set. The \nname\n needs to be one of: numPulse, numEpoch, epochDur, preDur, etc. These names match the 'Stimulus' parameters provided in the web interface. See the SetTrial() function in \ntreadmill.cpp\n for all possible trial parameters.\n\n\nEntering \ngetState\n in a serial port interface and the Arduino will return the current values for all trial parameters. This is a good way to find the names of trial parameters and then set them. For example, \nsettrial,epochDur,5000\n.\n\n\n=== Arduino State ===\ntrialNumber=0\ntrialDur=1000\nnumEpoch=1\nepochDur=1000\npreDur=1000\npostDur=1000\nnumPulse=3\npulseDur=1000\nuseMotor=1\nmotorDel=200\nmotorDur=200\nmotorSpeed=0\nmotorMaxSpeed=0\nversionStr=20160322\n=== Done ===\n\n\n\n\nPython interface\n\n\nAn experiment can be controlled from within Python by interacting with \ntreadmill.py\n. This includes interaction from a Python command line interface, a \niPython/Jupyter\n interface, or custom written Python scripts. The Python interface and Arduino interface share all trial parameter names.\n\n\nHere is an example of running an experiment from a Python script.\n\n\nimport treadmill\nt = treadmill.treadmill() # create a treadmill object\n\nt.startTrial() # start a new trial\nt.stopTrial() # stop a trial\n\nt.GetArduinoState() # get the current state with all trial parameters (see Arduino getstate serial command).\nt.settrial('epochDur',5000) # set the value of 'epochDur' trial parameter to 5000 ms\n\nt.startTrial() # start a new trial\n\n\n\n\nWeb interface\n\n\nAn experiment can also be controlled through a web browser interface. Run the web interface with \npython treadmill_app.py\n. The code for this web interface, in \ntreadmill_app.py\n, uses the \nFlask\n Python library. Flask is a micro-framework that allows a web-server to be created and controlled all from within Python. To make the web client interactive, we use SocketIO to communicate between the web client and the Flask python server.\n\n\nConfiguring the web interface\n\n\nChange the default IP address and port of the web server in \ntreadmill_app.py\n.\n\n\n\n\n\n\nTo run the web server on the machines local network IP, port 5010\n\n\n\n\nsocketio.run(app, host='0.0.0.0', port=5010, use_reloader=True)\n\n\n\n\n\n\n\n\nTo run the web server on localhost 127.0.0.1:5010, use this if using a single machine (no LAN needed)\n\n\n\n\nsocketio.run(app, host='', port=5010, use_reloader=True)\n\n\n\n\n\n\n\n\nClient side\n\n\nThe \nweb interface\n is using a number of client and server libraries. See \nindex.html\n and \nanalysis2.html\n for client-side code.\n\n\n\n\nSocket-io\n allows the Flask server to push updates to web-page without reloading the page\n\n\nBootstrap\n for page layout, buttons, sliders, value display\n\n\njquery\n to handle logic of user interface\n\n\nplotly.js\n to plot the arduino stimulus\n\n\nhighcharts.js\n to plot a trial in real-time while it is running\n\n\njqgrid\n to display a table of trials from disk\n\n\n\n\nConlusion\n\n\nWe have provided a description of all the pieces necessary to construct a system to control an experiment using an Arduino from Python. By creating this system with open-source hardware and software, our aim is to lower the barrier of entry to get started with implementing custom built experiments.", 
            "title": "home"
        }, 
        {
            "location": "/#introduction", 
            "text": "This is documentation for controlling a behavioral experiment using an Arduino microcontroller using Python. The experiment can be controlled from a Python command line or with an easy to use web browser interface. Included in this system is an option to simultaneously record video using a Rapsberry Pi video camera. Our goal is to provide a starting point for open-source behavioral experiments that can be extended to new experimental designs.    Figure 1. Web-browser interface.  The top section provides an interface to start/stop a trial and plots real-time feedback as the trial is running.  The  Stimulus  section provides an interface to set stimulus parameters and to upload these parameters to an Arduino. This section also provides a plot of the stimulus waveform based on the current set of parameters.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#system-design", 
            "text": "The core system consists of an Arduino, a stepper motor and motor driver, and a rotary encoder. The system comes together with a circular  treadmill  that can be driven by the stepper motor and whos current position is read using the rotary encoder.  The Arduino can be controlled with serial commands and can be triggered with general purpose digital input-output (GPIO) pulses. By relying on serial commands and GPIO pulses, this system is not dependent on the details of other pieces of equipment already in place for an experiment and can be extended to new and unique experimental configurations.  Using the provided Python code, an experiment can be controlled from a Python command prompt or a web browser interface.   Optionally, if this code is run on a Raspberry Pi, we provide Python code to simultaneously trigger and time-stamp video recording during an experiment. Please see our  Trigger Camera  documentation for a full dscription of how to integrate video recording into this system  We are routinely using this treadmill and video aquisition system while simultaneously acquiring in vivo two-photon images using ScanImage software (in Matlab) with National Instruments data acquisition cards.  See the  parts list  for a full list of parts, prices, and links to buy online.", 
            "title": "System design"
        }, 
        {
            "location": "/#arduino", 
            "text": "The majority of Arduino compatible micro-controllers will work with the code provided. We suggest starting with an Arduino  Uno . An good alternative Arduino compatible microcontroller is the  Teensy . The Teensy is advantageous as it has a more powerful processor, provides more low level interrupts, and has more memory than an Arduino Uno.", 
            "title": "Arduino"
        }, 
        {
            "location": "/#raspberry-pi", 
            "text": "The  Raspberry Pi  is a fully functional credit-card sized computer that runs Linux. It comes with USB, Ethernet, Wifi, and HDMI ports. It can be used as a host computer to program an Arduino using the Arduino IDE and can easily run Python code. A unique feature of the Pi is that it has built in digital GPIO. Thus, a Raspberry Pi can send/receive GPIO signals to/from most laboratory equipment including an Arduino. The Pi can be equipped with a dedicated video camera (5MP or 8MP) that can be controlled from Python and can be (relatively) precisely triggered by GPIO pulses. Given its small footprint, a Raspberry Pi is easily integrated into the same electronics box as the Arduino.  Please note, the GPIO ports on the Rapsberry Pi are only 3.5V tolerant while most laboratory equipment (including many Arduinos and National Instruments boards) use 5V GPIO. Thus, a logic-level converter is needed to convert between 3.5V on the Pi to 5V on other equipment.  As the Raspberry Pi is running a full Linux operating system, the precision and reliability of the GPIO pins is lower than can be achieved using a dedicated microcontroller like an Arduino. Thus, we have built this system using a Teensy microcontroller as a 'pass through' device to record the precise timing of experimental events to then be compared to and to calibrate the performance of the Raspberry Pi.", 
            "title": "Raspberry Pi"
        }, 
        {
            "location": "/#wiring-the-system", 
            "text": "Wire the stepper motor to the motor driver  Wire the Arduino to the motor driver  Wire the rotary encoder to the Arduino  Wire the Arduino to existing lab equipment  Wire the Raspberry Pi to the Arduino.   Here, we are wiring the system to interact with ScanImage software via National Instruments DAQ boards. This can easily be modified by wiring the system to other in-place acquisition systems such as those from Scientifica, Bruger (Prarie), Zeiss, or Nikon.  Keep in mind, the Raspberry Pi GPIO pins are  not  5V tolerant. Use a 5V to 3.5V level shifter to wire the Raspberry Pi to 5V GPIO signals. A Teensy microcontroller is advantageous in that it will accept 5V GPIO input but only outputs 3.5V GPIO. Thus, a Teensy and Raspberry Pi GPIO pins can be directly wired without a level shifter.", 
            "title": "Wiring the system"
        }, 
        {
            "location": "/#treadmill", 
            "text": "See the  images  page and the  treadmill section  of the parts list.  Building the treamill is easy but finding the pieces to build with can be time-consuming and frustrating. A good starting point is to use  Actobotics  parts from  ServoCity  or  Sparkfun . In particular,  ServoCity , has made a useful set of visual guides and project ideas that are really helpful in designing hardware components. Structural components include: frames, rods, bearings, clamps, and motor mounts.", 
            "title": "Treadmill"
        }, 
        {
            "location": "/#upload-code-to-the-arduino", 
            "text": "The source code for the Arduino can be found in  /arduino/src/treadmill.cpp .", 
            "title": "Upload code to the Arduino"
        }, 
        {
            "location": "/#required-libraries", 
            "text": "Non-blocking Arduino libraries need to be used, otherwise the system will not perform well. Without non-blocking libraries, the code to turn the stepper motor will block other code like reading the rotary encoder and vica versa. Using these non-blocking libraries ensures that (but do not gaurantee) the stepper motor movement does not stutter and all the rotary encoder positions are logged.   AccelStepper  library to control stepper motor  Rotary encoder library from  PJRC", 
            "title": "Required libraries"
        }, 
        {
            "location": "/#arduino-ide", 
            "text": "Use the standard  Arduino IDE  to upload  treadmill.cpp  to an Arduino. Make sure the required Arduino libraries are installed. Be sure to activate additional  low level interrupts  if using an Arduino Uno.", 
            "title": "Arduino IDE"
        }, 
        {
            "location": "/#platformio", 
            "text": "Code can also be uploaded to an Arduino using  PlatformIo . This has the distinct advantage that code can be compiled and uploaded from the command line on a headless computer including a Raspberry Pi. Please see this blog post to Install PlatformIO, compile code and upload it to an Arduino.", 
            "title": "Platformio"
        }, 
        {
            "location": "/#low-level-interrupts", 
            "text": "The Arduino Uno only comes with two pins (2 and 3) capable of low-level interrupts and more pins need to be enabled. Two low level interrupts are needed for the Rotary Encoder, another for a GPIO trigger, and another for GPIO pulses coming from a frame clock. See  Pin-change interrupts  for information on exposing additional pins as low-level interrupts.  We have included a compiler directive  _expose_interrupts_  in the  treadmill.cpp  Arduino code that, if activated, will run code to expose the needed interrupts on an Arduino Uno.   If using PlatformIO, this is taken care of in the [env] section of platformio.ini  If using the arduino IDE,  define _expose_interrupts_ = 1  must be included in  treadmill.cpp   //Uncomment this line if running on an Arduino Uno and compiling with the arduino IDE\n//#define _expose_interrupts_ 1", 
            "title": "Low Level Interrupts"
        }, 
        {
            "location": "/#python-server-setup", 
            "text": "Download and install  Anaconda . Anaconda is a  python  installation that will install many commonly used libraries. It is much easier to get started with Anaconda rather than a basic installation of Python.", 
            "title": "Python server setup"
        }, 
        {
            "location": "/#python-libraries", 
            "text": "Install additional required python libraries using the included requirements.txt file  pip install -r requirements.txt  Here is the requirements.txt file  eventlet =0.18.4\nFlask =0.10.1\nFlask-Markdown =0.3\nFlask-SocketIO =1.0\nplatformio =2.8.5\nplotly =1.9.6\npyserial =3.0.1  Required python libraries on Raspberry Pi  pip install -r raspberry_requirements.txt  picamera\nRPi.GPIO", 
            "title": "Python libraries"
        }, 
        {
            "location": "/#running-an-experiment", 
            "text": "At its core, an experiment is run on an Arduino by interacting with  treadmill.cpp  through a serial port interface. In addition, a Python command line interface and a web based interface are provided.  These interfaces can be extended by directly interacting with the Arduino code in  treadmill.cpp  (with serial commands), the python code in  treadmill.py , or the web server code in  treadmill_app.py .", 
            "title": "Running an experiment"
        }, 
        {
            "location": "/#arduino-serial-interface", 
            "text": "The Arduino code  treadmill.cpp  provides a set of serial port commands to get/set parameters and start/stop a trial. Once the code is uploaded to an Arduino, any serial port interface will allow control of an experiment as follows.  startTrial # start a trial\nstopTrial # stop a trial\ngetState #\nsettrial,[name],[value]  settrial  takes the  name  and  value  of a trial parameter to set. The  name  needs to be one of: numPulse, numEpoch, epochDur, preDur, etc. These names match the 'Stimulus' parameters provided in the web interface. See the SetTrial() function in  treadmill.cpp  for all possible trial parameters.  Entering  getState  in a serial port interface and the Arduino will return the current values for all trial parameters. This is a good way to find the names of trial parameters and then set them. For example,  settrial,epochDur,5000 .  === Arduino State ===\ntrialNumber=0\ntrialDur=1000\nnumEpoch=1\nepochDur=1000\npreDur=1000\npostDur=1000\nnumPulse=3\npulseDur=1000\nuseMotor=1\nmotorDel=200\nmotorDur=200\nmotorSpeed=0\nmotorMaxSpeed=0\nversionStr=20160322\n=== Done ===", 
            "title": "Arduino serial interface"
        }, 
        {
            "location": "/#python-interface", 
            "text": "An experiment can be controlled from within Python by interacting with  treadmill.py . This includes interaction from a Python command line interface, a  iPython/Jupyter  interface, or custom written Python scripts. The Python interface and Arduino interface share all trial parameter names.  Here is an example of running an experiment from a Python script.  import treadmill\nt = treadmill.treadmill() # create a treadmill object\n\nt.startTrial() # start a new trial\nt.stopTrial() # stop a trial\n\nt.GetArduinoState() # get the current state with all trial parameters (see Arduino getstate serial command).\nt.settrial('epochDur',5000) # set the value of 'epochDur' trial parameter to 5000 ms\n\nt.startTrial() # start a new trial", 
            "title": "Python interface"
        }, 
        {
            "location": "/#web-interface", 
            "text": "An experiment can also be controlled through a web browser interface. Run the web interface with  python treadmill_app.py . The code for this web interface, in  treadmill_app.py , uses the  Flask  Python library. Flask is a micro-framework that allows a web-server to be created and controlled all from within Python. To make the web client interactive, we use SocketIO to communicate between the web client and the Flask python server.", 
            "title": "Web interface"
        }, 
        {
            "location": "/#configuring-the-web-interface", 
            "text": "Change the default IP address and port of the web server in  treadmill_app.py .    To run the web server on the machines local network IP, port 5010   socketio.run(app, host='0.0.0.0', port=5010, use_reloader=True)     To run the web server on localhost 127.0.0.1:5010, use this if using a single machine (no LAN needed)   socketio.run(app, host='', port=5010, use_reloader=True)", 
            "title": "Configuring the web interface"
        }, 
        {
            "location": "/#client-side", 
            "text": "The  web interface  is using a number of client and server libraries. See  index.html  and  analysis2.html  for client-side code.   Socket-io  allows the Flask server to push updates to web-page without reloading the page  Bootstrap  for page layout, buttons, sliders, value display  jquery  to handle logic of user interface  plotly.js  to plot the arduino stimulus  highcharts.js  to plot a trial in real-time while it is running  jqgrid  to display a table of trials from disk", 
            "title": "Client side"
        }, 
        {
            "location": "/#conlusion", 
            "text": "We have provided a description of all the pieces necessary to construct a system to control an experiment using an Arduino from Python. By creating this system with open-source hardware and software, our aim is to lower the barrier of entry to get started with implementing custom built experiments.", 
            "title": "Conlusion"
        }, 
        {
            "location": "/images/", 
            "text": "table, td, th {    \n    border: 0px solid #ddd;\n    text-align: left;\n}\n\ntable {\n    border-collapse: collapse;\n    width: 100%;\n}\n\nth, td {\n    padding: 15px;\n}\n\n\n\n\nTreadmill\n\n\n\n\n\n    \n\n    \n\n    \n\n\n    \n\nDetailed view of circular treadmill including\n\n\n\n\n10\" acrylic disk (top)\n\nActobotics frame (horizontal aluminum arm)\n\nStepper motor (bottom)\n\nRotary encoder (left)\n\nGears to couple the motor and disk to the rotary encoder\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n    \n\n    \n\n\n    \n\n    \n\n    \n\n\n\n\n\n\n\n\nTreadmill on the scope", 
            "title": "images"
        }, 
        {
            "location": "/images/#treadmill", 
            "text": "Detailed view of circular treadmill including  10\" acrylic disk (top) Actobotics frame (horizontal aluminum arm) Stepper motor (bottom) Rotary encoder (left) Gears to couple the motor and disk to the rotary encoder", 
            "title": "Treadmill"
        }, 
        {
            "location": "/images/#treadmill-on-the-scope", 
            "text": "", 
            "title": "Treadmill on the scope"
        }, 
        {
            "location": "/parts/", 
            "text": "Parts List\n\n\nArduino\n\n\nUse the Teensy32 Arduino because it has a smaller form factor, more powerful processor, more low level interrupts, and more memory then an Arduino Unu R3. Use the Big Easy Motor Driver to use larger stepper motors.\n\n\n\n\n\n\n\n\nQuatity\n\n\nItem\n\n\nCost\n\n\nLink\n\n\n\n\n\n\n\n\n\n\n1\n\n\nArduino Uno R3\n\n\n$25\n\n\narduino.cc\n\n\n\n\n\n\n1\n\n\nTeensy32\n\n\n$30\n\n\npjrc.com\n\n\n\n\n\n\n1\n\n\nEasy Driver Motor Driver\n\n\n$15\n\n\nsparkfun\n\n\n\n\n\n\n1\n\n\nBig Easy Driver Motor Driver\n\n\n$20\n\n\nsparkfun\n\n\n\n\n\n\n\n\nRaspberry Pi\n\n\nA good way to get most of the parts needed (except camera) is to buy a Raspberry Pi starter kit from \nCanakit\n.\n\n\n\n\n\n\n\n\nQuatity\n\n\nItem\n\n\nCost\n\n\nLink\n\n\n\n\n\n\n\n\n\n\n1\n\n\nRaspberry Pi 3\n\n\n$35\n\n\nelement14\n\n\n\n\n\n\n1\n\n\n16GB class 10 micro SD Memory Card\n\n\n$xxx\n\n\nxxx\n\n\n\n\n\n\n1\n\n\n5V 2A AC/DC power\n\n\n$8\n\n\nadafruit\n\n\n\n\n\n\n1\n\n\nPi NoIR Camera\n\n\n$30\n\n\nadafruit\n\n\n\n\n\n\n1\n\n\nPi Camera Ribbon cable (2 meters)\n\n\n$6\n\n\nadafruit\n\n\n\n\n\n\n1\n\n\nPi Camera HDMI extension cable\n\n\n$15\n\n\ntindie\n\n\n\n\n\n\n4\n\n\nIR LED, 840-850 nm\n\n\n$1 each\n\n\nsparkfun\n\n\n\n\n\n\n1\n\n\n4-channel Logic Level Converter (Bi-Directional)\n\n\n$4\n\n\nSparkfun\n, \nAdafruit\n\n\n\n\n\n\n\n\n\n\n960 nm IR LEDs do not work well with Pi NoIR camera.\n\n\n\n\nMotors and encoders\n\n\n\n\n\n\n\n\nQuatity\n\n\nItem\n\n\nCost\n\n\nLink\n\n\n\n\n\n\n\n\n\n\n1\n\n\nStepper Motor (12V, 0.33 A)\n\n\n$15\n\n\nsparkfun\n\n\n\n\n\n\n1\n\n\nRotary Encoder (\nHoneywell-600-128-CBL\n)\n\n\n$38\n\n\ndigitkey\n\n\n\n\n\n\n1\n\n\n12V AC/DC Adapter (for the stepper motor)\n\n\n$xxx\n\n\nxxx\n\n\n\n\n\n\n\n\nElectronics\n\n\n\n\n\n\n\n\nQuatity\n\n\nItem\n\n\nCost\n\n\nLink\n\n\n\n\n\n\n\n\n\n\n1\n\n\nBreadboard\n\n\n$xxx\n\n\nxxx\n\n\n\n\n\n\n1\n\n\nJumper wires (M/M)\n\n\n$xxx\n\n\nxxx\n\n\n\n\n\n\n1\n\n\nJumper wires (M/F)\n\n\n$xxx\n\n\nxxx\n\n\n\n\n\n\n1\n\n\nJumper wires (F/F)\n\n\n$xxx\n\n\nxxx\n\n\n\n\n\n\n\n\n\n\nTreadmill\n\n\nThese are \nActobotics\n parts from \nServoCity\n\n\n\n\n\n\n\n\nQuatity\n\n\nItem\n\n\nCost\n\n\nPart #\n\n\nLink\n\n\n\n\n\n\n\n\n\n\n\n\nAluminum channels\n\n\n\n\n\n\nlink\n\n\n\n\n\n\n4\n\n\n1.50 inch Aluminum Channel\n\n\n2.99\n\n\n585440\n\n\n\n\n\n\n\n\n4\n\n\n6.00 inch Aluminum Channel\n\n\n5.99\n\n\n585446\n\n\n\n\n\n\n\n\n1\n\n\n9.00 inch Aluminum Channel\n\n\n7.99\n\n\n585450\n\n\n\n\n\n\n\n\n1\n\n\n15 inch Aluminum Channel\n\n\n11.99\n\n\n585458\n\n\n\n\n\n\n\n\n\n\nShafts and shaft couplers\n\n\n\n\n\n\nlink\n\n\n\n\n\n\n2\n\n\n1/4 inch x12 inch Precision Shaft\n\n\n3.59\n\n\n634178\n\n\n\n\n\n\n\n\n2\n\n\n1/4 inch x4 inch Precision Shaft\n\n\n1.49\n\n\n634164\n\n\n\n\n\n\n\n\n1\n\n\n1/4 inch x6 inch Precision Shaft\n\n\n2.09\n\n\n634168\n\n\n\n\n\n\n\n\n2\n\n\n1/4 inch to 5mm Set Screw Shaft Coupler\n\n\n4.99\n\n\n625120\n\n\n\n\n\n\n\n\n2\n\n\n1/4 inch to 1/4 inch Set Screw Shaft Coupler\n\n\n4.99\n\n\n625104\n\n\n\n\n\n\n\n\n\n\nCouplers and adapters\n\n\n\n\n\n\nlink\n\n\n\n\n\n\n8\n\n\n1/4 inch Bore Clamping Hub (0.770 inch)\n\n\n7.99\n\n\n545588\n\n\n\n\n\n\n\n\n4\n\n\n1/4 inch Bore Set Screw Hub (0.770 inch)\n\n\n4.99\n\n\n545548\n\n\n\n\n\n\n\n\n2\n\n\nStepper Motor Mount (NEMA 17)\n\n\n7.49\n\n\n555152\n\n\n\n\n\n\n\n\n4\n\n\n1/4-20 Round Screw Plate\n\n\n3.99\n\n\n545468\n\n\n\n\n\n\n\n\n2\n\n\nLarge Square Screw Plate\n\n\n2.69\n\n\n585430\n\n\n\n\n\n\n\n\n1\n\n\n90 Degree Quad Hub Mount C\n\n\n5.99\n\n\n545360\n\n\n\n\n\n\n\n\n1\n\n\n90 Degree Quad Hub Mount D\n\n\n5.99\n\n\n545324\n\n\n\n\n\n\n\n\n\n\nBall bearings\n\n\n\n\n\n\nlink\n\n\n\n\n\n\n3\n\n\n.250 inch ID x .500 inch OD Flanged Ball Bearing (Stainless Steel) 2 pack\n\n\n1.99\n\n\n535198\n\n\n\n\n\n\n\n\n1\n\n\nDual Ball Bearing Hub A\n\n\n6.99\n\n\n545444\n\n\n\n\n\n\n\n\n1\n\n\n1/4 inch Shafting \n Tubing Spacers (12 pk)\n\n\n1.69\n\n\n633104\n\n\n\n\n\n\n\n\n\n\nGears\n\n\n\n\n\n\nlink\n\n\n\n\n\n\n1\n\n\n16T, 0.250 inch Bore, 32P Bevel Gear\n\n\n5.99\n\n\n615442\n\n\n\n\n\n\n\n\n1\n\n\n32T, 0.250 inch Bore, 32P Bevel Gear\n\n\n7.99\n\n\n615444\n\n\n\n\n\n\n\n\n1\n\n\n16T, 5mm Bore, 32P Bevel Gear\n\n\n5.99\n\n\n615438\n\n\n\n\n\n\n\n\n2\n\n\n48 Tooth, 32 Pitch Hub Gear (3/16 inch Face)\n\n\n5.20\n\n\nRHA32-36-48\n\n\n\n\n\n\n\n\n\n\nFasteners\n\n\n\n\n\n\nlink\n\n\n\n\n\n\n24\n\n\n6-32x3/8 inch Pan Head Phillips Machine Screws (Zinc-Plated)\n\n\n0.06\n\n\n90272A146\n\n\n\n\n\n\n\n\n8\n\n\n1/2 inch 1/4-20 Flat Head Phillips Machine Screws\n\n\n0.38\n\n\n90273A537\n\n\n\n\n\n\n\n\n1\n\n\n3/32 Hex Key\n\n\n1.39\n\n\n57185A11\n\n\n\n\n\n\n\n\n6\n\n\n.250 in L x 6-32 Zinc-Plated Alloy Steel Socket Head Cap Screw (25 pk)\n\n\n1.69\n\n\n632106", 
            "title": "parts"
        }, 
        {
            "location": "/parts/#parts-list", 
            "text": "", 
            "title": "Parts List"
        }, 
        {
            "location": "/parts/#arduino", 
            "text": "Use the Teensy32 Arduino because it has a smaller form factor, more powerful processor, more low level interrupts, and more memory then an Arduino Unu R3. Use the Big Easy Motor Driver to use larger stepper motors.     Quatity  Item  Cost  Link      1  Arduino Uno R3  $25  arduino.cc    1  Teensy32  $30  pjrc.com    1  Easy Driver Motor Driver  $15  sparkfun    1  Big Easy Driver Motor Driver  $20  sparkfun", 
            "title": "Arduino"
        }, 
        {
            "location": "/parts/#raspberry-pi", 
            "text": "A good way to get most of the parts needed (except camera) is to buy a Raspberry Pi starter kit from  Canakit .     Quatity  Item  Cost  Link      1  Raspberry Pi 3  $35  element14    1  16GB class 10 micro SD Memory Card  $xxx  xxx    1  5V 2A AC/DC power  $8  adafruit    1  Pi NoIR Camera  $30  adafruit    1  Pi Camera Ribbon cable (2 meters)  $6  adafruit    1  Pi Camera HDMI extension cable  $15  tindie    4  IR LED, 840-850 nm  $1 each  sparkfun    1  4-channel Logic Level Converter (Bi-Directional)  $4  Sparkfun ,  Adafruit      960 nm IR LEDs do not work well with Pi NoIR camera.", 
            "title": "Raspberry Pi"
        }, 
        {
            "location": "/parts/#motors-and-encoders", 
            "text": "Quatity  Item  Cost  Link      1  Stepper Motor (12V, 0.33 A)  $15  sparkfun    1  Rotary Encoder ( Honeywell-600-128-CBL )  $38  digitkey    1  12V AC/DC Adapter (for the stepper motor)  $xxx  xxx", 
            "title": "Motors and encoders"
        }, 
        {
            "location": "/parts/#electronics", 
            "text": "Quatity  Item  Cost  Link      1  Breadboard  $xxx  xxx    1  Jumper wires (M/M)  $xxx  xxx    1  Jumper wires (M/F)  $xxx  xxx    1  Jumper wires (F/F)  $xxx  xxx", 
            "title": "Electronics"
        }, 
        {
            "location": "/parts/#treadmill", 
            "text": "These are  Actobotics  parts from  ServoCity     Quatity  Item  Cost  Part #  Link       Aluminum channels    link    4  1.50 inch Aluminum Channel  2.99  585440     4  6.00 inch Aluminum Channel  5.99  585446     1  9.00 inch Aluminum Channel  7.99  585450     1  15 inch Aluminum Channel  11.99  585458      Shafts and shaft couplers    link    2  1/4 inch x12 inch Precision Shaft  3.59  634178     2  1/4 inch x4 inch Precision Shaft  1.49  634164     1  1/4 inch x6 inch Precision Shaft  2.09  634168     2  1/4 inch to 5mm Set Screw Shaft Coupler  4.99  625120     2  1/4 inch to 1/4 inch Set Screw Shaft Coupler  4.99  625104      Couplers and adapters    link    8  1/4 inch Bore Clamping Hub (0.770 inch)  7.99  545588     4  1/4 inch Bore Set Screw Hub (0.770 inch)  4.99  545548     2  Stepper Motor Mount (NEMA 17)  7.49  555152     4  1/4-20 Round Screw Plate  3.99  545468     2  Large Square Screw Plate  2.69  585430     1  90 Degree Quad Hub Mount C  5.99  545360     1  90 Degree Quad Hub Mount D  5.99  545324      Ball bearings    link    3  .250 inch ID x .500 inch OD Flanged Ball Bearing (Stainless Steel) 2 pack  1.99  535198     1  Dual Ball Bearing Hub A  6.99  545444     1  1/4 inch Shafting   Tubing Spacers (12 pk)  1.69  633104      Gears    link    1  16T, 0.250 inch Bore, 32P Bevel Gear  5.99  615442     1  32T, 0.250 inch Bore, 32P Bevel Gear  7.99  615444     1  16T, 5mm Bore, 32P Bevel Gear  5.99  615438     2  48 Tooth, 32 Pitch Hub Gear (3/16 inch Face)  5.20  RHA32-36-48      Fasteners    link    24  6-32x3/8 inch Pan Head Phillips Machine Screws (Zinc-Plated)  0.06  90272A146     8  1/2 inch 1/4-20 Flat Head Phillips Machine Screws  0.38  90273A537     1  3/32 Hex Key  1.39  57185A11     6  .250 in L x 6-32 Zinc-Plated Alloy Steel Socket Head Cap Screw (25 pk)  1.69  632106", 
            "title": "Treadmill"
        }, 
        {
            "location": "/dev/", 
            "text": "Development\n\n\nThese are development notes taken during the development of the Treadmill.\n\n\nmkDocs\n\n\nThis documentation is written in markdown and a static site is generated with \nmkDocs\n using the \nCinder\n theme. Previously I have used Jekyll which is amazing. Going with mkDocs to see if a simple site is acceptable.\n\n\nWhen writing markdown, serve a mkDocs site locally with\n\n\ncd docs/\nmkdocs serve --dev-addr=0.0.0.0:8000 # serves built site on LAN IP\nmkdocs serve # serves built site on localhost at 127.0.0.1:8000\n\nmkdocs build #generates the site into docs/site/\n\n\n\n\nDeploy to Github gh-pages\n\n\nDeploy to github gh-pages by follow mkDocs \ndeployment instructions\n.\n\n\nmkdocs gh-deploy\n will use the gh-pages branch of repository specified in \nmkdocs.yml\n\n\n# this will deploy to github gh-pages specified in mkdocs.yml\ncd docs #should have mkdocs.yml file\nmkdocs build --clean\nmkdocs gh-deploy --clean \n#site is then available at\nhttp://cudmore.github.io/treadmill\n\n\n\nI am doing this on OSX. Not doing this on Debian because I do not have git/github properly configured.\n\n\nTweak Cinder\n\n\nAlong the way I have actually contributed to \nCinder\n, the mkDocs template that makes this site. See \nhere\n.\n\n\nUse 'pip show mkdocs' to figure out where your cinder files are\n\n\npip show mkdocs\n/home/cudmore/anaconda2/lib/python2.7/site-packages\n\n\n\nGenerate a single PDF from mkDocs site\n\n\nUse \nmkdocs-pandoc\n to convert the mkdocs site into a single pdf. This creates a table of contents and appends all .md files using \npandoc\n as a backend.\n\n\ncd docs\nmkdocs2pandoc \n mydocs.pd\npandoc --toc -f markdown+grid_tables+table_captions -o mydocs.pdf mydocs.pd   # Generate PDF\npandoc --toc -f markdown+grid_tables -t epub -o mydocs.epub mydocs.pd         # Generate EPUB\n\n\n\n\nI found it easy to do this on OSX using the pandoc installer. I did not get this working on Debian.\n\n\nPlatformio\n\n\nIf you prefer you can use [Platformio][5] to do everything from a command line. This has the distinct advantage that you can compile and upload code from a headless computer including a Raspberry Pi or any system running Linux.\n\n\nPlatformio is a python library so you should be good to go with \npip install platformio\n. \n\n\nHave a look [here][6] to create a platformio.ini file for your specific Arduino. Here are three different board configurations\n\n\nplatformio init --board uno # arduino uno\nplatformio init --board pro16MHzatmega328 # generic arduino pro \nplatformio init --board nodemcuv2 # arduino node mcu\n\n\n\n\nAfter 'platformio init', platformio.ini will have environment configurations. You only want to have one of these blocks at a time to simplify compilation. For example [env:uno].\n\n\n[env:uno]\nplatform = atmelavr\nframework = arduino\nboard = uno\nbuild_flags = -D _expose_interrupts_ #creates compiler directive\n\n#[env:pro16MHzatmega328]\n#platform = atmelavr\n#framework = arduino\n#board = pro16MHzatmega328\n\n#[env:nodemcuv2]\n#platform = espressif\n#framework = arduino\n#board = nodemcuv2\n#upload_port = /dev/ttyUSB0\n\n\n\n\nCompile, upload, and clean Arduino code with\n\n\nplatformio run #compile arduino code\nplatformio run --target upload #compile and upload\nplatformio run --target clean #clean project \n\n\n\n\nFinally, once the code is running you can open a serial port connection with\n\n\nplatformio serialports monitor -p /dev/ttyUSB0 -b 115200 #a serial port monitor\n\n\n\n\nSpecifying the correct serial port for the Arduino is critical. Specify this in the treadmill.py file.\n\n\n#serialStr = '/dev/tty.usbmodem618661' #teensy at work\n#serialStr = '/dev/tty.usbmodem618661' #teensy?\n#serialStr = '/dev/ttyUSB0' #hand soldered arduino micro (home debian)\n#serialStr = '/dev/tty.usbserial-A50285BI' # hand soldered at work\nserialStr = '/dev/ttyACM0' #uno\n\n\n\n\n5V Relay\n\n\nA relay allows a 3.5 or 5 V DIO pin to turn a higher voltage switch on and off. For example, you use a 5V relay to turn a 12V line on and off.\n\n\nHow to wire a 5V relay is here\n\n\nhttp://www.codeguru.com/IoT/understanding-relays-in-iot-development.html", 
            "title": "dev"
        }, 
        {
            "location": "/dev/#development", 
            "text": "These are development notes taken during the development of the Treadmill.", 
            "title": "Development"
        }, 
        {
            "location": "/dev/#mkdocs", 
            "text": "This documentation is written in markdown and a static site is generated with  mkDocs  using the  Cinder  theme. Previously I have used Jekyll which is amazing. Going with mkDocs to see if a simple site is acceptable.  When writing markdown, serve a mkDocs site locally with  cd docs/\nmkdocs serve --dev-addr=0.0.0.0:8000 # serves built site on LAN IP\nmkdocs serve # serves built site on localhost at 127.0.0.1:8000\n\nmkdocs build #generates the site into docs/site/", 
            "title": "mkDocs"
        }, 
        {
            "location": "/dev/#deploy-to-github-gh-pages", 
            "text": "Deploy to github gh-pages by follow mkDocs  deployment instructions .  mkdocs gh-deploy  will use the gh-pages branch of repository specified in  mkdocs.yml  # this will deploy to github gh-pages specified in mkdocs.yml\ncd docs #should have mkdocs.yml file\nmkdocs build --clean\nmkdocs gh-deploy --clean \n#site is then available at\nhttp://cudmore.github.io/treadmill  I am doing this on OSX. Not doing this on Debian because I do not have git/github properly configured.", 
            "title": "Deploy to Github gh-pages"
        }, 
        {
            "location": "/dev/#tweak-cinder", 
            "text": "Along the way I have actually contributed to  Cinder , the mkDocs template that makes this site. See  here .  Use 'pip show mkdocs' to figure out where your cinder files are  pip show mkdocs\n/home/cudmore/anaconda2/lib/python2.7/site-packages", 
            "title": "Tweak Cinder"
        }, 
        {
            "location": "/dev/#generate-a-single-pdf-from-mkdocs-site", 
            "text": "Use  mkdocs-pandoc  to convert the mkdocs site into a single pdf. This creates a table of contents and appends all .md files using  pandoc  as a backend.  cd docs\nmkdocs2pandoc   mydocs.pd\npandoc --toc -f markdown+grid_tables+table_captions -o mydocs.pdf mydocs.pd   # Generate PDF\npandoc --toc -f markdown+grid_tables -t epub -o mydocs.epub mydocs.pd         # Generate EPUB  I found it easy to do this on OSX using the pandoc installer. I did not get this working on Debian.", 
            "title": "Generate a single PDF from mkDocs site"
        }, 
        {
            "location": "/dev/#platformio", 
            "text": "If you prefer you can use [Platformio][5] to do everything from a command line. This has the distinct advantage that you can compile and upload code from a headless computer including a Raspberry Pi or any system running Linux.  Platformio is a python library so you should be good to go with  pip install platformio .   Have a look [here][6] to create a platformio.ini file for your specific Arduino. Here are three different board configurations  platformio init --board uno # arduino uno\nplatformio init --board pro16MHzatmega328 # generic arduino pro \nplatformio init --board nodemcuv2 # arduino node mcu  After 'platformio init', platformio.ini will have environment configurations. You only want to have one of these blocks at a time to simplify compilation. For example [env:uno].  [env:uno]\nplatform = atmelavr\nframework = arduino\nboard = uno\nbuild_flags = -D _expose_interrupts_ #creates compiler directive\n\n#[env:pro16MHzatmega328]\n#platform = atmelavr\n#framework = arduino\n#board = pro16MHzatmega328\n\n#[env:nodemcuv2]\n#platform = espressif\n#framework = arduino\n#board = nodemcuv2\n#upload_port = /dev/ttyUSB0  Compile, upload, and clean Arduino code with  platformio run #compile arduino code\nplatformio run --target upload #compile and upload\nplatformio run --target clean #clean project   Finally, once the code is running you can open a serial port connection with  platformio serialports monitor -p /dev/ttyUSB0 -b 115200 #a serial port monitor  Specifying the correct serial port for the Arduino is critical. Specify this in the treadmill.py file.  #serialStr = '/dev/tty.usbmodem618661' #teensy at work\n#serialStr = '/dev/tty.usbmodem618661' #teensy?\n#serialStr = '/dev/ttyUSB0' #hand soldered arduino micro (home debian)\n#serialStr = '/dev/tty.usbserial-A50285BI' # hand soldered at work\nserialStr = '/dev/ttyACM0' #uno", 
            "title": "Platformio"
        }, 
        {
            "location": "/dev/#5v-relay", 
            "text": "A relay allows a 3.5 or 5 V DIO pin to turn a higher voltage switch on and off. For example, you use a 5V relay to turn a 12V line on and off.  How to wire a 5V relay is here  http://www.codeguru.com/IoT/understanding-relays-in-iot-development.html", 
            "title": "5V Relay"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\ntreadmill was created by \nRobert H Cudmore\n.", 
            "title": "about"
        }, 
        {
            "location": "/about/#about", 
            "text": "treadmill was created by  Robert H Cudmore .", 
            "title": "About"
        }
    ]
}